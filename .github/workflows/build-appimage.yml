name: Build AppImage

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'src/**'
      - 'scripts/build-appimage.sh'
      - '.github/workflows/build-appimage.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'src/**'
      - 'scripts/build-appimage.sh'
      - '.github/workflows/build-appimage.yml'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create GitHub release'
        required: false
        default: false
        type: boolean
      release_notes:
        description: 'Release notes (optional)'
        required: false
        default: ''
        type: string

env:
  DOTNET_VERSION: '8.0.x'
  APP_NAME: 'overlay-companion-mcp'

jobs:
  build-appimage:
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.version.outputs.version }}
      appimage-name: ${{ steps.version.outputs.appimage-name }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Needed for version calculation

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Calculate version
      id: version
      run: |
        # Calculate version based on YYYY.MM.DD[.N] schema
        DATE=$(date +%Y.%m.%d)

        # Check if we already have releases today
        TODAY_RELEASES=$(gh release list --limit 100 --json tagName --jq '.[] | select(.tagName | startswith("'$DATE'")) | .tagName' | wc -l || echo "0")

        if [ "$TODAY_RELEASES" -eq 0 ]; then
          VERSION="$DATE"
        else
          # Find the highest build number for today
          HIGHEST_BUILD=$(gh release list --limit 100 --json tagName --jq '.[] | select(.tagName | startswith("'$DATE'")) | .tagName' | sed "s/$DATE\.//" | sed "s/$DATE/0/" | sort -n | tail -1 || echo "0")
          NEXT_BUILD=$((HIGHEST_BUILD + 1))
          VERSION="$DATE.$NEXT_BUILD"
        fi

        APPIMAGE_NAME="${{ env.APP_NAME }}-${VERSION}-x86_64.AppImage"

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "appimage-name=$APPIMAGE_NAME" >> $GITHUB_OUTPUT
        echo "üìÖ Version: $VERSION"
        echo "üì¶ AppImage: $APPIMAGE_NAME"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Install system dependencies
      run: |
        echo "üì¶ Installing system dependencies..."
        sudo apt-get update -qq
        sudo apt-get install -y -qq \
          wget \
          imagemagick \
          desktop-file-utils \
          appstream-util \
          fuse \
          libfuse2 \
          libgtk-4-dev \
          libgtk-4-1 \
          pkg-config \
          libglib2.0-dev \
          libcairo2-dev \
          libpango1.0-dev \
          libgdk-pixbuf2.0-dev \
          libgraphene-1.0-dev \
          libepoxy-dev
        echo "‚úÖ System dependencies installed"

    - name: Restore .NET dependencies
      run: |
        cd src
        dotnet restore

    - name: Build AppImage
      run: |
        export APP_VERSION="${{ steps.version.outputs.version }}"
        chmod +x ./scripts/build-appimage.sh
        ./scripts/build-appimage.sh

    - name: Validate AppImage
      run: |
        APPIMAGE_PATH="build/${{ steps.version.outputs.appimage-name }}"

        # Debug: List build directory contents
        echo "üìã Build directory contents:"
        ls -la build/ || echo "Build directory not found"

        # Check if AppImage was created
        if [ ! -f "$APPIMAGE_PATH" ]; then
          echo "‚ùå AppImage not found at $APPIMAGE_PATH"
          echo "üìã Current directory: $(pwd)"
          echo "üìã Looking for: $APPIMAGE_PATH"
          exit 1
        fi

        # Run comprehensive validation
        chmod +x scripts/validate-appimage.sh
        ./scripts/validate-appimage.sh "$APPIMAGE_PATH"

    - name: Upload AppImage artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.version.outputs.appimage-name }}
        path: build/${{ steps.version.outputs.appimage-name }}
        retention-days: 30

    - name: Upload build logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-logs-${{ steps.version.outputs.version }}
        path: |
          build/*.log
          build/publish/
        retention-days: 7

  create-release:
    needs: build-appimage
    runs-on: ubuntu-latest
    # Only attempt releases on the upstream repo owner; skip silently elsewhere
    if: |
      (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true') ||
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        github.event_name == 'release'
      ) && github.repository_owner == 'RyansOpenSauceRice'
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download AppImage artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ needs.build-appimage.outputs.appimage-name }}
        path: ./release/

    - name: Generate checksums
      id: checksums
      run: |
        APPIMAGE_PATH="./release/${{ needs.build-appimage.outputs.appimage-name }}"

        # Generate checksums in GearLever order (md5, sha1, sha256)
        MD5_HASH=$(md5sum "$APPIMAGE_PATH" | cut -d' ' -f1)
        SHA1_HASH=$(sha1sum "$APPIMAGE_PATH" | cut -d' ' -f1)
        SHA256_HASH=$(sha256sum "$APPIMAGE_PATH" | cut -d' ' -f1)

        echo "md5=$MD5_HASH" >> $GITHUB_OUTPUT
        echo "sha1=$SHA1_HASH" >> $GITHUB_OUTPUT
        echo "sha256=$SHA256_HASH" >> $GITHUB_OUTPUT

        echo "Generated checksums:"
        echo "md5: $MD5_HASH"
        echo "sha1: $SHA1_HASH"
        echo "sha256: $SHA256_HASH"

    - name: Generate release notes
      id: release-notes
      run: |
        VERSION="${{ needs.build-appimage.outputs.version }}"
        APPIMAGE_NAME="${{ needs.build-appimage.outputs.appimage-name }}"

        # Create release notes
        cat > release_notes.md << EOF
        # Overlay Companion MCP v${VERSION}

        ## üì¶ AppImage Release

        **Download:** \`${APPIMAGE_NAME}\`

        ### Installation

        1. Download the AppImage file
        2. Make it executable: \`chmod +x ${APPIMAGE_NAME}\`
        3. Run: \`./${APPIMAGE_NAME}\`

        ### Features

        - üñ•Ô∏è **Screen Interaction**: AI-assisted screen capture and overlay drawing
        - ü§ñ **MCP Integration**: Compatible with Jan.ai and other MCP clients
        - üõ°Ô∏è **Human-in-the-Loop**: Safety controls and user confirmation for automated actions
        - üñ±Ô∏è **Input Simulation**: Controlled mouse and keyboard automation
        - üì± **Multi-Monitor**: Support for complex display configurations
        - üé® **Overlay System**: Draw highlights, labels, and annotations on screen

        ### System Requirements

        - Linux x86_64
        - FUSE support (for AppImage execution)
        - Wayland compositor (preferred) or X11 (fallback)
        - .NET 8.0 runtime (bundled in AppImage)

        ### Usage

        #### Direct Execution
        \`\`\`bash
        ./${APPIMAGE_NAME}
        \`\`\`

        #### MCP Server Mode
        \`\`\`bash
        ./${APPIMAGE_NAME} --mcp
        \`\`\`

        #### HTTP Bridge Mode
        \`\`\`bash
        ./${APPIMAGE_NAME} --http
        \`\`\`

        ### Integration with Jan.ai

        Add to your Jan.ai MCP configuration:
        \`\`\`json
        {
          "mcpServers": {
            "overlay-companion": {
              "command": "/path/to/${APPIMAGE_NAME}",
              "args": ["--mcp"]
            }
          }
        }
        \`\`\`

        ---

        **Build Information:**
        - Version: ${VERSION}
        - Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        - Platform: Linux x86_64
        - .NET Version: 8.0
        - MCP SDK: 0.3.0-preview.3

        ---

        ### Checksums (GearLever compatible)

        \`\`\`
        md5: ${{ steps.checksums.outputs.md5 }}
        sha1: ${{ steps.checksums.outputs.sha1 }}
        sha256: ${{ steps.checksums.outputs.sha256 }}
        \`\`\`

        EOF

        # Add custom release notes if provided
        if [ -n "${{ github.event.inputs.release_notes }}" ]; then
          echo "" >> release_notes.md
          echo "## Additional Notes" >> release_notes.md
          echo "" >> release_notes.md
          echo "${{ github.event.inputs.release_notes }}" >> release_notes.md
        fi

        echo "Generated release notes:"
        cat release_notes.md

    - name: Create GitHub Release
      continue-on-error: true
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.build-appimage.outputs.version }}
        name: "Overlay Companion MCP v${{ needs.build-appimage.outputs.version }}"
        body_path: release_notes.md
        files: |
          release/${{ needs.build-appimage.outputs.appimage-name }}
        draft: false
        prerelease: false
        make_latest: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Update latest release info
      run: |
        echo "üì¶ AppImage: ${{ needs.build-appimage.outputs.appimage-name }}"
        echo "üè∑Ô∏è Version: ${{ needs.build-appimage.outputs.version }}"
        echo "‚ÑπÔ∏è  If release wasn't created (permissions), this step is informational only."

  test-appimage:
    needs: build-appimage
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download AppImage artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ needs.build-appimage.outputs.appimage-name }}
        path: ./test/

    - name: Install test dependencies
      run: |
        echo "üß™ Installing test dependencies..."
        sudo apt-get update -qq
        sudo apt-get install -y -qq fuse libfuse2 xvfb weston xwayland dbus-x11 libgl1 libegl1
        echo "‚úÖ Test dependencies installed"

    - name: Test AppImage execution and extraction
      working-directory: test
      timeout-minutes: 5
      run: |
        chmod +x ${{ needs.build-appimage.outputs.appimage-name }}

        # Test basic execution with virtual display (help) - capture output for analysis
        echo "üß™ Testing AppImage help command (max 60 seconds)..."
        
        # Use a more aggressive timeout and background process management
        if timeout 60s xvfb-run -a ./${{ needs.build-appimage.outputs.appimage-name }} --help > appimage_help_test.log 2>&1; then
          echo "‚úÖ AppImage help test completed successfully"
          echo "üìã Help output preview:"
          head -10 appimage_help_test.log || true
        else
          EXIT_CODE=$?
          echo "‚ö†Ô∏è  AppImage help test timed out or failed (exit code: $EXIT_CODE)"
          echo "üìã Captured output:"
          cat appimage_help_test.log || echo "No output captured"

          # Check for critical dependency errors that should fail the build
          if grep -q "Unable to load shared library.*Gtk" appimage_help_test.log 2>/dev/null; then
            echo "‚ùå CRITICAL: GTK4 dependencies missing from AppImage"
            exit 1
          elif grep -q "DllNotFoundException" appimage_help_test.log 2>/dev/null; then
            echo "‚ùå CRITICAL: Native library dependencies missing from AppImage"
            exit 1
          elif grep -q "Unhandled exception" appimage_help_test.log 2>/dev/null; then
            echo "‚ùå CRITICAL: Unhandled exception during AppImage startup"
            exit 1
          elif [ $EXIT_CODE -eq 124 ]; then
            echo "‚ö†Ô∏è  Help command timed out - this may indicate GUI initialization issues"
            echo "‚ÑπÔ∏è  Continuing with extraction test as timeout doesn't indicate critical failure"
          else
            echo "‚ö†Ô∏è  Help test failed but no critical dependency errors detected"
          fi
        fi

        # Test AppImage extraction (with timeout)
        echo "üß™ Testing AppImage extraction (max 30 seconds)..."
        if timeout 30s ./${{ needs.build-appimage.outputs.appimage-name }} --appimage-extract; then
          echo "‚úÖ AppImage extraction completed successfully"
        else
          echo "‚ùå CRITICAL: AppImage extraction failed or timed out"
          exit 1
        fi

        # Verify extracted contents
        echo "üîç Verifying extracted contents..."
        ls -la squashfs-root/
        test -f squashfs-root/AppRun || { echo "‚ùå AppRun missing"; exit 1; }
        test -f squashfs-root/usr/bin/overlay-companion-mcp || { echo "‚ùå Main executable missing"; exit 1; }
        test -f squashfs-root/*.desktop || { echo "‚ùå Desktop file missing"; exit 1; }
        echo "‚úÖ Core AppImage structure verified"

        # Check for GTK4 libraries in extracted AppImage
        echo "üîç Checking for GTK4 libraries in AppImage..."
        if find squashfs-root/usr/lib -name 'libgtk-4*.so*' 2>/dev/null | grep -q libgtk-4; then
          echo "‚úÖ GTK4 libraries found in AppImage"
          echo "üìã GTK4 library details:"
          find squashfs-root/usr/lib -name 'libgtk-4*.so*' 2>/dev/null | head -5
        else
          echo "‚ùå WARNING: GTK4 libraries not found in AppImage - runtime will require system GTK4"
          echo "üìã Available libraries (sample):"
          find squashfs-root/usr/lib -name '*.so*' 2>/dev/null | head -10 || true
        fi
        
        # Check for .NET-compatible symlinks
        echo "üîç Checking for .NET-compatible library symlinks..."
        if find squashfs-root/usr/lib -name 'Gtk.so' 2>/dev/null | grep -q Gtk.so; then
          echo "‚úÖ .NET-compatible GTK symlinks found"
        else
          echo "‚ö†Ô∏è  .NET-compatible GTK symlinks not found - may affect .NET GTK4 binding"
        fi

    - name: Smoke test (X11/Xvfb)
      timeout-minutes: 3
      env:
        OC_SMOKE_TEST: "1"
        HEADLESS: "0"
      run: |
        echo "üß™ Running AppImage smoke test (max 3 minutes)..."
        chmod +x tests/local-appimage-smoke.sh
        if timeout 180s xvfb-run -a bash tests/local-appimage-smoke.sh ./test/${{ needs.build-appimage.outputs.appimage-name }}; then
          echo "‚úÖ Smoke test completed successfully"
        else
          EXIT_CODE=$?
          echo "‚ö†Ô∏è  Smoke test failed or timed out (exit code: $EXIT_CODE)"
          if [ $EXIT_CODE -eq 124 ]; then
            echo "‚ùå CRITICAL: Smoke test timed out - AppImage may have startup issues"
            exit 1
          else
            echo "‚ùå CRITICAL: Smoke test failed"
            exit 1
          fi
        fi


    - name: Upload smoke logs (always)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: appimage-smoke-logs
        path: |
          /tmp/oc-appimage.log
          /tmp/appimage-wayland.log
          /tmp/weston.log
          /tmp/appimage_build.log
          /tmp/*appimage*.log
        if-no-files-found: ignore
        retention-days: 7

    - name: Smoke test (Wayland via weston headless + Xwayland)
      timeout-minutes: 3
      run: |
        echo "üß™ Running Wayland smoke test (max 3 minutes)..."
        chmod +x tests/ci/appimage-smoke-weston.sh || true
        if timeout 180s bash tests/ci/appimage-smoke-weston.sh ./test/${{ needs.build-appimage.outputs.appimage-name }}; then
          echo "‚úÖ Wayland smoke test completed successfully"
        else
          EXIT_CODE=$?
          echo "‚ö†Ô∏è  Wayland smoke test failed or timed out (exit code: $EXIT_CODE)"
          if [ $EXIT_CODE -eq 124 ]; then
            echo "‚ùå CRITICAL: Wayland smoke test timed out - AppImage may have startup issues"
            exit 1
          else
            echo "‚ùå CRITICAL: Wayland smoke test failed"
            exit 1
          fi
        fi

        echo "‚úÖ All AppImage tests passed"
