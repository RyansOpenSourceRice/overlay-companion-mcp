name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Deployment environment'
        required: false
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

env:
  DOTNET_VERSION: '8.0.x'
  NODE_VERSION: '18'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
  DOTNET_NOLOGO: true

jobs:
  # Quality Gates
  quality-gates:
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.deployment-check.outputs.should-deploy }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check deployment conditions
      id: deployment-check
      run: |
        SHOULD_DEPLOY="false"

        # Deploy on main branch pushes
        if [ "${{ github.ref }}" == "refs/heads/main" ] && [ "${{ github.event_name }}" == "push" ]; then
          SHOULD_DEPLOY="true"
        fi

        # Deploy on manual workflow dispatch
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          SHOULD_DEPLOY="true"
        fi

        echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        echo "üöÄ Should deploy: $SHOULD_DEPLOY"

  # Markdown Quality
  markdown-quality:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Install markdown tools
      run: |
        npm install -g markdownlint-cli cspell markdown-toc

    - name: Run markdown linting
      continue-on-error: true
      run: |
        echo "üîç Running markdown quality checks..."
        ./scripts/lint-markdown.sh

  # C# Quality and Build
  csharp-quality:
    runs-on: ubuntu-latest

    outputs:
      build-success: ${{ steps.build-check.outputs.success }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: |
        cd src
        dotnet restore

    - name: Code formatting check
      continue-on-error: true
      run: |
        cd src
        echo "üîç Applying code formatting..."
        dotnet format --verbosity minimal

    - name: Build and analyze
      id: build-check
      run: |
        cd src

        # Build with warnings as errors for quality
        if dotnet build --configuration Release --no-restore; then
          echo "success=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Build successful"
        else
          echo "success=false" >> $GITHUB_OUTPUT
          echo "‚ùå Build failed"
          exit 1
        fi

    - name: Security scan
      continue-on-error: true
      run: |
        cd src
        dotnet list package --vulnerable --include-transitive || echo "Security scan completed"

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: csharp-build-${{ github.sha }}
        path: src/bin/Release/
        retention-days: 1

  # Unit Tests (when implemented)
  unit-tests:
    runs-on: ubuntu-latest
    needs: csharp-quality
    if: needs.csharp-quality.outputs.build-success == 'true' && !github.event.inputs.skip_tests

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore dependencies
      run: |
        cd src
        dotnet restore

    - name: Run unit tests
      run: |
        cd src

        # Check if test projects exist
        if find . -name "*.Tests.csproj" -o -name "*Test*.csproj" | grep -q .; then
          echo "üß™ Running unit tests..."
          dotnet test --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage"
        else
          echo "‚ÑπÔ∏è No test projects found - skipping unit tests"
          echo "Consider adding test projects for better code quality"
        fi

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ github.sha }}
        path: |
          src/TestResults/
          src/**/coverage.cobertura.xml
        retention-days: 7

  # Integration Tests
  integration-tests:
    runs-on: ubuntu-latest
    needs: csharp-quality
    if: needs.csharp-quality.outputs.build-success == 'true' && !github.event.inputs.skip_tests

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Install system dependencies
      run: |
        sudo apt-get update
        # Only install basic dependencies for headless testing
        sudo apt-get install -y wl-clipboard grim slurp wtype

    - name: Build application
      run: |
        cd src
        dotnet build --configuration Release

    - name: Test application startup
      run: |
        cd src

        # Test basic application startup in headless mode (no GUI in CI)
        echo "üß™ Testing application startup..."
        if ! timeout 10s dotnet run --configuration Release -- --help --no-gui > startup_test.log 2>&1; then
          echo "üìã Startup test output:"
          cat startup_test.log
          
          # In headless mode, GTK4 errors should not occur
          if grep -q "Unable to load shared library.*Gtk" startup_test.log; then
            echo "‚ùå CRITICAL: GTK4 initialization attempted in headless mode"
            echo "üí° Check --no-gui flag is working properly"
            exit 1
          fi
          
          # Check for other critical errors
          if grep -q "Unhandled exception" startup_test.log; then
            echo "‚ùå CRITICAL: Unhandled exception occurred"
            exit 1
          fi
          
          # If timeout occurred but help was displayed, that's acceptable
          if grep -q "Usage:" startup_test.log || grep -q "Options:" startup_test.log; then
            echo "‚úÖ Application startup successful (timeout is expected)"
          else
            echo "‚ö†Ô∏è Application may have failed to start properly"
            exit 1
          fi
        else
          echo "‚úÖ Startup test completed successfully"
        fi

    - name: Test MCP server mode
      run: |
        cd src

        # Test MCP server initialization in headless mode (no GUI in CI)
        echo "üß™ Testing MCP server mode..."
        if ! timeout 10s dotnet run --configuration Release -- --mcp --test --no-gui > mcp_test.log 2>&1; then
          echo "üìã MCP test output:"
          cat mcp_test.log
          
          # In headless mode, GTK4 errors should not occur
          if grep -q "Unable to load shared library.*Gtk" mcp_test.log; then
            echo "‚ùå CRITICAL: GTK4 initialization attempted in headless mode"
            echo "üí° Check --no-gui flag is working properly"
            exit 1
          fi
          
          # Check for other critical errors
          if grep -q "Unhandled exception" mcp_test.log; then
            echo "‚ùå CRITICAL: Unhandled exception occurred"
            exit 1
          fi
          
          # If timeout occurred but no critical errors, that's acceptable for integration tests
          if grep -q "HTTP Transport listening on" mcp_test.log; then
            echo "‚úÖ MCP server started successfully (timeout is expected for integration test)"
          else
            echo "‚ö†Ô∏è MCP server may have failed to start properly"
            exit 1
          fi
        else
          echo "‚úÖ MCP test completed successfully"
        fi

  # Security Scan
  security-scan:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always() && github.repository_owner == 'RyansOpenSauceRice'
      with:
        sarif_file: 'trivy-results.sarif'
      continue-on-error: true

  # Build AppImage
  build-appimage:
    runs-on: ubuntu-latest
    needs: [quality-gates, markdown-quality, csharp-quality]
    if: needs.quality-gates.outputs.should-deploy == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Install AppImage dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y wget imagemagick desktop-file-utils appstream-util fuse libfuse2

    - name: Build AppImage
      run: |
        export APP_VERSION="$(date +%Y.%m.%d)"
        ./scripts/build-appimage.sh

    - name: Upload AppImage
      uses: actions/upload-artifact@v4
      with:
        name: appimage-${{ github.sha }}
        path: build/*.AppImage
        retention-days: 30

  # Deploy
  deploy:
    runs-on: ubuntu-latest
    needs: [quality-gates, build-appimage, unit-tests, integration-tests]
    if: |
      always() &&
      needs.quality-gates.outputs.should-deploy == 'true' &&
      needs.build-appimage.result == 'success' &&
      (needs.unit-tests.result == 'success' || needs.unit-tests.result == 'skipped') &&
      (needs.integration-tests.result == 'success' || needs.integration-tests.result == 'skipped')

    environment: ${{ github.event.inputs.deploy_environment || 'staging' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download AppImage
      uses: actions/download-artifact@v4
      with:
        name: appimage-${{ github.sha }}
        path: ./deploy/

    - name: Deploy to environment
      run: |
        ENV="${{ github.event.inputs.deploy_environment || 'staging' }}"
        echo "üöÄ Deploying to $ENV environment..."

        # List available AppImages
        ls -la deploy/

        if [ "$ENV" == "production" ]; then
          echo "üéØ Production deployment would happen here"
          echo "- Create GitHub release"
          echo "- Upload to distribution channels"
          echo "- Update documentation"
        else
          echo "üß™ Staging deployment completed"
          echo "- AppImage available for testing"
          echo "- Internal distribution updated"
        fi

    - name: Deployment summary
      run: |
        echo "=================================="
        echo "üéâ Deployment Summary"
        echo "=================================="
        echo "Environment: ${{ github.event.inputs.deploy_environment || 'staging' }}"
        echo "Version: $(date +%Y.%m.%d)"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        echo "=================================="

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy, quality-gates]
    if: always() && needs.quality-gates.outputs.should-deploy == 'true'

    steps:
    - name: Notify deployment status
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "‚úÖ Deployment successful!"
          echo "üéØ Environment: ${{ github.event.inputs.deploy_environment || 'staging' }}"
        else
          echo "‚ùå Deployment failed!"
          echo "üìã Check the logs for details"
        fi
